{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#how-to-add-a-new-page","title":"How to Add a New Page","text":"<p>We use MkDocs with auto-generated navigation. That means the folder and file structure inside <code>docs/</code> determines the sidebar tree. You don\u2019t need to edit <code>mkdocs.yml</code> manually.</p>"},{"location":"#1-create-the-markdown-file","title":"1. Create the Markdown File","text":"<ul> <li>Inside the <code>docs/</code> folder, create a new <code>.md</code> file in the right place.</li> <li>If needed, create sub-folders to reflect how you want the navigation to look.</li> </ul> <p>Example:</p> <pre><code>docs/\n  gameplay/\n    controls.md\n    combat.md\n  about.md\n</code></pre> <p>This will show up in the sidebar as:</p> <pre><code>Gameplay\n  Controls\n  Combat\nAbout\n</code></pre>"},{"location":"#2-preview-locally","title":"2. Preview Locally","text":"<ul> <li>Run the MkDocs dev server (<code>mkdocs serve</code>)</li> <li>Open http://127.0.0.1:8000 in your browser.</li> <li>Verify the page appears in the sidebar and renders correctly.</li> </ul> <p>\u26a0\ufe0f Important: MkDocs does not always render Markdown exactly like GitHub or VS Code\u2019s preview.</p> <ul> <li>Nested lists -&gt; MkDocs expects 4 spaces per indent level, while   GitHub/VS Code allow 2.</li> <li>Always confirm in the browser, not just in VS Code.</li> </ul>"},{"location":"#3-commit-your-changes","title":"3. Commit Your Changes","text":"<ul> <li>Stage and commit the new files:</li> </ul> <pre><code>git add docs/\ngit commit -m \"Add gameplay controls page\"\ngit push\n</code></pre>"},{"location":"#tips","title":"Tips","text":"<ul> <li>Use <code>#</code> for the page title. MkDocs will automatically use the first heading as   the page name.</li> <li>Keep file names in snake_case (<code>my_feature.md</code>) for consistency.</li> <li>Place images in <code>docs/assets/</code> and link with:</li> </ul> <pre><code>![Example](../assets/example.png)\n</code></pre> <p>\u2705 That\u2019s it \u2014 once pushed, the new page will appear on the site automatically.</p>"},{"location":"#adding-images-and-diagrams","title":"Adding Images and Diagrams","text":"<p>Our docs support multiple ways to include visuals, depending on complexity:</p>"},{"location":"#1-simple-diagrams-mermaid","title":"1. Simple Diagrams (Mermaid)","text":"<p>For flowcharts, sequence diagrams, or trees, use Mermaid.</p> <p>Example:</p> <pre><code>```mermaid\nflowchart LR\n  A[Start] --&gt; B{Choice?}\n  B --&gt;|Yes| C[Option 1]\n  B --&gt;|No| D[Option 2]\n```\n</code></pre> <p>This will render directly in the docs.</p> <pre><code>flowchart LR\n  A[Start] --&gt; B{Choice?}\n  B --&gt;|Yes| C[Option 1]\n  B --&gt;|No| D[Option 2]</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"#2-complex-diagrams-drawio","title":"2. Complex Diagrams (draw.io)","text":"<p>For freestyle or detailed diagrams:</p> <ol> <li>Create a <code>.drawio</code> file or save an existing one in <code>docs/drawio/</code>.</li> <li>Link it in your Markdown with the <code>mkdocs-drawio</code> plugin:</li> </ol> <pre><code>![](drawio/architecture.drawio)\n</code></pre> <ul> <li>The plugin will render it as an image in the page.</li> <li>You can always re-open the <code>.drawio</code> file in   draw.io / diagrams.net to edit.</li> </ul>"},{"location":"#3-arbitrary-images","title":"3. Arbitrary Images","text":"<p>For screenshots, concept art, or reference images:</p> <ol> <li>Place the file in <code>docs/assets/</code>.</li> <li>Link it with standard Markdown syntax:</li> </ol> <pre><code>![Example Screenshot](assets/example.png)\n</code></pre> <ul> <li>Use relative paths from the page where you add the link.</li> </ul> <p>\u2705 That\u2019s it \u2014 use the right tool for the right type of image:</p> <ul> <li>Mermaid \u2192 simple diagrams.</li> <li>Draw.io \u2192 complex, custom diagrams.</li> <li>Assets \u2192 any arbitrary image.</li> </ul>"},{"location":"design_decisions/","title":"\ud83e\udde0 Design Decisions","text":"<p>This document records high-level design and technical choices made during early development. Each section should summarize the current decision, rationale, an open questions to revisit later.</p>"},{"location":"design_decisions/#1-core-game-identity","title":"\ud83c\udfae 1. Core Game Identity","text":"<p>Goal: Describe what the game is and what defines its core experience.</p> <ul> <li> <p>Genre &amp; Inspiration:   Multiplayer roguevania inspired by Dead Cells and Hollow Knight.   Start as single-player.</p> </li> <li> <p>Core Loop Summary: e.g., Explore \u2192 Fight \u2192 Checkpoint \u2192 Upgrade \u2192 Repeat.</p> </li> <li> <p>Primary Pillars:</p> <ul> <li>Combat Feel</li> <li>Customizable Skills</li> <li>Story Integration</li> <li>Meta-Progression</li> </ul> </li> <li> <p>Rationale / Comments:</p> <ul> <li>TBD</li> </ul> </li> <li> <p>Open Questions:</p> <ul> <li>TBD</li> </ul> </li> </ul>"},{"location":"design_decisions/#2-primary-scenes","title":"\ud83e\udde9 2. Primary Scenes","text":"<p>Goal: Define how scenes, levels, and transitions are managed.</p>"},{"location":"design_decisions/#main-menu","title":"Main Menu","text":"<p>Where players start games and manages saves</p>"},{"location":"design_decisions/#hub-safe-area","title":"Hub / Safe Area","text":""},{"location":"design_decisions/#dungeon","title":"Dungeon","text":"<p>Each scene contains a sub-level. Several sub-levels are chained to form a meta- level. Clearing a meta-level for the first time unlocks new safe area and advances story progression.</p> <p>Dungeons are generated procedurally using the Edgar Pro package.</p> <p>Boss rooms can be standalone scenes or part of dungeons.</p>"},{"location":"design_decisions/#3-data-asset-structure","title":"\ud83d\udce6 3. Data &amp; Asset Structure","text":"<p>Goal: Establish how gameplay data and assets are represented and loaded.</p> Aspect Decision Item &amp; Skill Definitions ScriptableObjects Enemy Definitions Prefabs / ScriptableObjects NPC Definitions Prefabs / ScriptableObjects Scene Assets Unity Scenes Asset Loading Strategy Unity built-in (evolve later) <ul> <li> <p>Rationale / Comments:   -</p> </li> <li> <p>Open Questions:   -</p> </li> </ul>"},{"location":"design_decisions/#4-player-control-combat","title":"\u2694\ufe0f 4. Player Control &amp; Combat","text":"<p>Goal: Decide how movement and combat systems are implemented.</p> Element Decision Controller Framework Corgi Engine Input System Unity Input System (Corgi Input Manager) Core Combat Style Melee-focused, limited ranged Parry / Dodge / Skills Basic set planned for prototype <ul> <li> <p>Rationale / Comments:   -</p> </li> <li> <p>Open Questions:   -</p> </li> </ul>"},{"location":"design_decisions/#5-skill-grid-system","title":"\ud83e\udde0 5. Skill Grid System","text":"<p>Goal: Define how customizable skills are represented and executed.</p> Component Description Trigger Blocks Action Blocks Resource / Balance Mechanic Mana / Overheat <ul> <li> <p>Rationale / Comments:   -</p> </li> <li> <p>Open Questions:   -</p> </li> </ul>"},{"location":"design_decisions/#6-save-progression-system","title":"\ud83d\udcbe 6. Save &amp; Progression System","text":"<p>Goal: Define what data is saved and how progression works.</p> Category Description Meta Progression Unlocks, upgrades, bag expansion Run Data Inventory, skill grid, temporary stats Save Format JSON Checkpoints Hub areas or safe levels between dungeons <ul> <li> <p>Rationale / Comments:   -</p> </li> <li> <p>Open Questions:   -</p> </li> </ul>"},{"location":"design_decisions/#7-code-architecture-communication","title":"\ud83e\uddf0 7. Code Architecture &amp; Communication","text":"<p>Goal: Outline core architectural patterns to ensure scalability and decoupling.</p> Aspect Decision Messaging / Event System Direct references / C# Events System Management GameManager that holds all persistent singletons <ul> <li> <p>Rationale / Comments:   -</p> </li> <li> <p>Open Questions:   -</p> </li> </ul>"},{"location":"design_decisions/#8-art-ux-direction","title":"\ud83c\udfa8 8. Art &amp; UX Direction","text":"<p>Goal: Define visual and UI goals early for consistency.</p> Aspect Decision Visual Style Likely 3D low-poly Camera 2D side-scroller UI Style Any Input Target keyboard first + controller <ul> <li> <p>Rationale / Comments:</p> <ul> <li>Compared to pixel arts, it's easier to find low-poly assets with consistent style</li> <li>We could even make our own models</li> </ul> </li> <li> <p>Open Questions:   -</p> </li> </ul>"},{"location":"design_decisions/#9-technical-workflow","title":"\ud83c\udfd7\ufe0f 9. Technical Workflow","text":"<p>Goal: Define development and collaboration conventions.</p> Area Decision Version Control Git / GitHub Package Management Unity package manager Folder Structure (to be filled) Build Targets Windows first / Apple optional / Linux later Level Authoring Edgar Unity + handcrafted room prefabs <ul> <li> <p>Rationale / Comments:   -</p> </li> <li> <p>Open Questions:   -</p> </li> </ul>"},{"location":"design_decisions/#10-known-technical-risks-research-topics","title":"\ud83d\udd2e 10. Known Technical Risks / Research Topics","text":"<p>Goal: Track areas that need investigation or pose integration risk.</p> Topic Notes / Owner / Status Skill Grid performance Save / serialization format Edgar Unity procedural API <ul> <li>Rationale / Comments:   -</li> </ul>"},{"location":"design_decisions/#11-dungeon-tile-types","title":"11. Dungeon Tile Types","text":"<ul> <li>Basic</li> <li>Spikes</li> <li>Moving Platforms</li> <li>Ladders</li> </ul>"},{"location":"design_decisions/#12-next-steps-action-items","title":"\u2705 12. Next Steps / Action Items","text":"Owner Task Priority Notes <p>Tip: Keep this document concise \u2014 it should evolve with the project, not become a wiki. Each section represents a decision snapshot you can revisit as the design matures.</p>"},{"location":"game_overview/","title":"\ud83c\udfae Game Overview -- [Working Title]","text":""},{"location":"game_overview/#elevator-pitch","title":"Elevator Pitch","text":"<p>A multiplayer roguevania inspired by Dead Cells and Hollow Knight. Players explore procedurally generated dungeons, fight challenging enemies and bosses with tight platformer combat, and progress through a branching world using checkpoints and meta-progression.</p>"},{"location":"game_overview/#core-gameplay-pillars","title":"Core Gameplay Pillars","text":"<ol> <li> <p>Exploration</p> <ul> <li>Dungeons are generated using Dead Cells-style room graphs (via Edgar Unity).</li> <li>Each run feels fresh, while handcrafted rooms maintain quality and variety.</li> </ul> </li> <li> <p>Combat</p> <ul> <li>Fast-paced, melee-focused combat built around attack, dodge, and parry.</li> <li>Skills and abilities come from items equipped in a skill grid system,   allowing for both active and passive customization.</li> <li>Ranged combat will be added later but won\u2019t involve free aiming (fits   controller-first design).</li> </ul> </li> <li> <p>Multiplayer</p> <ul> <li>Cooperative play: explore and fight together in the same world.</li> <li>Story progression follows the host, with options to add \u201cspoiler   alerts\u201d for guests rather than blocking content.</li> <li>Single-scene multiplayer is the baseline; multi-scene support is a stretch   goal.</li> </ul> </li> </ol>"},{"location":"game_overview/#progression","title":"Progression","text":"<ul> <li> <p>Meta-progression (between runs):</p> <ul> <li>Unlock new items and skills.</li> <li>Expand bag size for more skill combinations.</li> <li>Gain stronger starting loadouts.</li> </ul> </li> <li> <p>Checkpoints (within runs):</p> <ul> <li>After clearing a section, players reach a hub/safe area.</li> <li>From here, they can:<ul> <li>Continue to the next dungeon with their current items.</li> <li>Restart from the beginning if they\u2019re unhappy with their build.</li> </ul> </li> <li>If players fail in the next section, this is also where they restarts.</li> <li>(\u26a0\ufe0f Design note: Some feel \u201crerolling items in early levels\u201d is core to   roguelikes -- we may refine this system to preserve that fun.)</li> </ul> </li> </ul>"},{"location":"game_overview/#structure-of-a-run","title":"Structure of a Run","text":"<ol> <li>Start in a hub or checkpoint.</li> <li>Explore randomized dungeons filled with enemies, traps, and secrets.</li> <li>Gather items/skills to expand combat options.</li> <li>Defeat the boss to unlock the next section.</li> <li>Repeat until story completion or defeat.</li> </ol>"},{"location":"game_overview/#tone-setting","title":"Tone / Setting","text":"<ul> <li>Still undecided.</li> <li>Needs to support a mix of procedural environments (dungeons, biomes) and   handcrafted hub/safe areas.</li> <li>Will heavily influence enemy, item, and NPC design.</li> </ul>"},{"location":"game_overview/#key-differentiators","title":"Key Differentiators","text":"<ul> <li>Checkpoint system -&gt; Players skip trivial early content once mastered,   diving directly into new challenges.</li> <li>Multiplayer co-op \u2192 Rare in roguevania design, giving the genre a social   element.</li> <li>Bag-based skill system \u2192 Customizable triggers and effects make builds   more dynamic than traditional static upgrades.</li> </ul>"},{"location":"skill_grid/","title":"\u2694\ufe0f Skill Grid \u2013 Overview","text":""},{"location":"skill_grid/#core-idea","title":"Core Idea","text":"<p>The Skill Grid is a programmable system that lets players define their own active and passive abilities. Instead of fixed skill trees, abilities emerge from how players arrange and connect blocks within the grid. This creates flexible builds, encourages experimentation, and makes progression (larger grids, more block types) meaningful.</p>"},{"location":"skill_grid/#core-components","title":"Core Components","text":"<ol> <li> <p>Trigger Blocks</p> <ul> <li>Activate when certain conditions are met.</li> <li>Two main categories:<ul> <li>Input Triggers -&gt; bound to key/button presses (function like   traditional active skills).</li> <li>Event Triggers -&gt; tied to gameplay events (e.g. on damage taken,   on perfect parry, on kill).</li> </ul> </li> <li>Can connect to one or more Action Blocks.</li> </ul> </li> <li> <p>Action Blocks</p> <ul> <li>Execute effects when activated by a Trigger.</li> <li>Examples:<ul> <li>Heal the player.</li> <li>Damage nearby enemies.</li> <li>Summon a projectile or shield.</li> </ul> </li> <li>Serve as the \u201cpayload\u201d of the skill system.</li> </ul> </li> <li> <p>Advanced/Utility Blocks (Future Expansion)</p> <ul> <li>Add variety, creativity, and depth:<ul> <li>Relay / Chain Trigger -&gt; activates when another Trigger fires.</li> <li>Copy Block -&gt; duplicates the behavior of an adjacent block.</li> <li>Modifier Blocks -&gt; alter nearby Actions (e.g. convert damage to   fire, increase radius, add poison).</li> </ul> </li> </ul> </li> </ol>"},{"location":"skill_grid/#skill-types-supported","title":"Skill Types Supported","text":"<ul> <li>Active Skills -&gt; Player presses a button, the bound Trigger fires, linked   Actions execute.</li> <li>Reactive Skills -&gt; Gameplay events automatically trigger Actions (like   passives).</li> </ul>"},{"location":"skill_grid/#early-scope-vs-long-term","title":"Early Scope vs. Long-Term","text":"<ul> <li>Early versions will focus on the basics:<ul> <li>A small set of Input and Event Triggers.</li> <li>A few versatile Actions (heal, damage, buff).</li> </ul> </li> <li>Later expansions can introduce fun/complex blocks for creative expression.</li> </ul>"},{"location":"skill_grid/#balancing-the-skill-grid","title":"\u2696\ufe0f Balancing the Skill Grid","text":""},{"location":"skill_grid/#the-core-problem","title":"The Core Problem","text":"<ul> <li>Players can chain Triggers and Actions to create loops.</li> <li>Loops can be internal (Trigger A -&gt; B -&gt; A) or external (Trigger -&gt;   Event -&gt; other Trigger -&gt; first Trigger again).</li> <li>While we want to allow clever combos and \u201cpower moments,\u201d we must avoid   infinite spam that trivializes gameplay.</li> </ul>"},{"location":"skill_grid/#mitigation-systems","title":"Mitigation Systems","text":""},{"location":"skill_grid/#1-mana-system-resource-cost","title":"1. Mana System (Resource Cost)","text":"<ul> <li>Each Action Block consumes mana when executed.</li> <li>If insufficient mana:<ul> <li>Option A: Action sits in a queue until mana regenerates.</li> <li>Option B: Action is discarded.</li> </ul> </li> <li>Mana regenerates slowly over time.</li> <li>Benefits:<ul> <li>Familiar RPG mechanic (easy to explain).</li> <li>Prevents infinite loops by draining resources.</li> </ul> </li> <li>Risks:<ul> <li>Strong mana regen builds might still break balance unless capped.</li> </ul> </li> </ul>"},{"location":"skill_grid/#2-overheat-system-execution-cost","title":"2. Overheat System (Execution Cost)","text":"<ul> <li>Each Action Block generates heat.</li> <li>Heat builds up with rapid or repeated activations.</li> <li>If total heat exceeds threshold:<ul> <li>All queued actions are cleared.</li> <li>Triggers deactivate for a cooldown window.</li> <li>(Optional) Player takes backlash damage.</li> </ul> </li> <li>Heat dissipates gradually over time.</li> <li>Benefits:<ul> <li>Encourages pacing and rhythm in combos.</li> <li>\u201cOverheat shutdown\u201d feels thematic (fits tech or magic equally well).</li> </ul> </li> <li>Risks:<ul> <li>May frustrate players if it feels too punishing. Needs good   feedback/telegraphing.</li> </ul> </li> </ul>"},{"location":"skill_grid/#3-trigger-rate-limits-throttle","title":"3. Trigger Rate Limits (Throttle)","text":"<ul> <li>Put a per-trigger cooldown (e.g. Trigger A can only fire once every 0.5s).</li> <li>Ensures loops can\u2019t run infinitely fast.</li> <li>Benefits:<ul> <li>Simple, predictable cap.</li> </ul> </li> <li>Risks:<ul> <li>Feels restrictive \u2014 undermines the \u201cprogrammable\u201d fantasy.</li> </ul> </li> </ul>"},{"location":"skill_grid/#4-decay-diminishing-returns","title":"4. Decay / Diminishing Returns","text":"<ul> <li>Repeatedly triggering the same loop reduces effectiveness:<ul> <li>Each repeat deals less damage / heals less until it bottoms out.</li> </ul> </li> <li>Benefits:<ul> <li>Keeps combos fun for a while, then self-limiting.</li> </ul> </li> <li>Risks:<ul> <li>Harder for players to understand (\u201cwhy did my damage shrink?\u201d).</li> <li>Harder to program because actions are still getting executed.</li> </ul> </li> </ul>"},{"location":"skill_grid/#5-external-anchors-event-only-chains","title":"5. External Anchors (Event-Only Chains)","text":"<ul> <li>Restrict some triggers to external events only (damage taken, parry, kill).</li> <li>They cannot be re-triggered by other triggers.</li> <li>Benefits:<ul> <li>Loops can\u2019t self-sustain forever.</li> </ul> </li> <li>Risks:<ul> <li>Adds hidden rules players must learn.</li> <li>Does not fundamentally prevent infinite loops.</li> <li>Requires careful design of triggers.</li> </ul> </li> </ul>"},{"location":"skill_grid/#design-approach-recommendation","title":"Design Approach Recommendation","text":"<ul> <li>Hybrid system:<ul> <li>Start with Mana and/or Overheat as the main balancing axes.</li> <li>If not enough, add light rate limits on a per-trigger basis.</li> </ul> </li> <li>This gives:<ul> <li>Resource management (mana).</li> <li>Combo pacing (overheat).</li> <li>Safety net (rate limit).</li> </ul> </li> <li>Allows crazy combos, but forces players to think about when to unleash them.</li> </ul>"},{"location":"skill_grid/#minimal-example","title":"Minimal Example","text":"<p>In this example, there are 3 trigger blocks and 4 action blocks.</p> <ul> <li>When player presses the skill 1 button, the two actions above are executed   in order: First a fireball is shot, then the player gets an ATK buff.</li> <li>When player presses the skill 2 button, the five blocks in the row above are   activated from left to right, but there are only two valid action blocks   within: First a fireball is shot, then the player gets an DEF buff.</li> <li>When the player character is healed in any way, the two blocks on the right of   Trigger (On Heal) are activated: An ATK buff followed by a heal action<ul> <li>Note that the heal action would re-trigger the Trigger (On Heal),   causing a loop. This is where the balancing mechanic discussed above kicks   in.</li> </ul> </li> </ul>"},{"location":"implementation/SceneTransition/","title":"Scene Transitions","text":"<p>This document explains how scene and room transitions are handled in our game, using and extending features provided by Corgi Engine and Edgar Unity.</p>"},{"location":"implementation/SceneTransition/#1-basics","title":"1. Basics","text":"<p>Corgi Engine provides several built-in systems to handle scene transitions, teleportation, and level management. These systems include scripted scene loading functions and ready-to-use components.</p>"},{"location":"implementation/SceneTransition/#11-scene-loading-functions","title":"1.1 Scene Loading Functions","text":"<p>All Corgi Engine scene loading methods support loading screens, which can be customized to display arbitrary content or disabled entirely.</p>"},{"location":"implementation/SceneTransition/#mmsceneloadingmanager","title":"<code>MMSceneLoadingManager</code>","text":"<p><code>LoadScene(string sceneName)</code></p> <ul> <li>A static and minimal function for switching to another scene.</li> <li>Use it like Unity\u2019s native <code>SceneManager.LoadScene</code>.</li> <li>Does not require a <code>LevelManager</code> instance.</li> <li>Does not apply fade or disable character controls automatically.</li> </ul>"},{"location":"implementation/SceneTransition/#levelmanager","title":"<code>LevelManager</code>","text":"<p><code>GotoLevel(string levelName, bool fadeOut = true, bool save = true)</code></p> <ul> <li>A member function that must be called on a LevelManager instance   (usually the singleton).</li> <li>Provides extra functionality:<ul> <li>Optionally performs a fade-out/in transition.</li> <li>Temporarily disables player character abilities until the new scene is   loaded.</li> <li>Handles save data if enabled.</li> </ul> </li> </ul> <p>This is usually the preferred method when a <code>LevelManager</code> instance is available.</p>"},{"location":"implementation/SceneTransition/#12-scene-transition-components","title":"1.2 Scene Transition Components","text":"<p>Corgi Engine provides a few reusable components that automate transitions when attached to a <code>GameObject</code> in a scene:</p>"},{"location":"implementation/SceneTransition/#finishlevel","title":"FinishLevel","text":"<p>Path: <code>Assets/CorgiEngine/Common/Scripts/Spawn/FinishLevel.cs</code></p> <ul> <li>Inherits from <code>ButtonActivated</code>.</li> <li>Attach to a <code>GameObject</code> with a <code>Collider2D</code>.</li> <li>Configure a target scene name in the inspector.</li> <li>On activation (via button press or trigger enter), it will load the   specified scene.</li> <li>By default, the player will spawn at the first <code>Checkpoint</code> found in the   new scene.</li> </ul>"},{"location":"implementation/SceneTransition/#gotolevelentrypoint","title":"GoToLevelEntryPoint","text":"<p>Path: <code>Assets/CorgiEngine/Common/Scripts/Spawn/GoToLevelEntryPoint.cs</code></p> <ul> <li>Inherits from <code>FinishLevel</code>.</li> <li>Adds the ability to specify a spawn entry point index.</li> <li>If the <code>LevelManager</code> in the destination scene finds a   registered entry point with that index, the player will spawn there.</li> <li>Otherwise, it falls back to the first checkpoint (same as <code>FinishLevel</code>).</li> <li>Note: Point of Entry and Checkpoint are two distinct position   initialization methods. A Point of Entry does not need to be a Checkpoint,   nor does a Checkpoint need to register as a Point of Entry. That being   said, nothing prevents an object from being both a Point of Entry and a   Checkpoint.</li> </ul>"},{"location":"implementation/SceneTransition/#teleporter","title":"Teleporter","text":"<p>Path: <code>Assets/CorgiEngine/Common/ScriptsCinemachine/Environment/Teleporter.cs</code></p> <ul> <li>Also inherits from <code>ButtonActivated</code>.</li> <li>Used for teleportation within the same scene.</li> <li>Attach to a GameObject with a collider and specify another <code>Teleporter</code> as the   target.</li> <li>On activation, moves the player instantly to the target\u2019s position.</li> </ul>"},{"location":"implementation/SceneTransition/#13-levelmanager-and-character-bounds","title":"1.3 LevelManager and Character Bounds","text":"<p>Two additional components play an important role in Corgi\u2019s scene and world management:</p> <ul> <li>LevelManager:<ul> <li>Handles scene loading, checkpoint logic, respawns, and player persistence.</li> <li>Register points of entry for <code>GoToLevelEntryPoint</code> in the <code>PointsOfEntry</code>   list.</li> <li>Define <code>Center</code> and <code>Extent</code> (size) of level bounds in the inspector.</li> <li>There is a \"Debug Spawn\" field that overrides spawn points so we usually   want to leave it empty.</li> </ul> </li> </ul> <p>Note: The default implementation is a singleton, which may not fit projects using additive scene loading or multiple level contexts (e.g., multiplayer hosts).</p> <ul> <li>Character Level Bounds:   Keeps the player within the level and kills or stops them when leaving bounds.   Player may fail to spawn properly when the selected spawn/entry point is   outside the level bounds.</li> </ul> <p>Known bug: Removing it can cause physics instabilities such as bouncing or clipping through the floor.</p>"},{"location":"implementation/SceneTransition/#2-cross-scene-room-transitions","title":"2. Cross-Scene Room Transitions","text":"<p>This setup handles moving between separate Unity scenes \u2014 for example, transitioning between a central hub area and individual room scenes. Each room is stored in its own scene, and the player can freely enter or exit these rooms  When returning to the hub, the player should reappear at the specific entrance  they originally used, rather than the default spawn point.</p>"},{"location":"implementation/SceneTransition/#hub-room","title":"Hub -&gt; Room","text":"<ol> <li>In the hub scene, locate each room entrance object.</li> <li>Add a <code>BoxCollider2D</code> (set as a trigger) and a <code>FinishLevel</code> component.</li> <li>Configure the <code>FinishLevel</code> component to load the target room scene as    the next level.<ul> <li>For rooms with a single entrance/exit, this setup is sufficient.</li> <li>If a room has multiple exits and you want to control which door the player   appears at, use <code>GoToLevelEntryPoint</code> instead of <code>FinishLevel</code>.</li> </ul> </li> </ol>"},{"location":"implementation/SceneTransition/#room-hub","title":"Room -&gt; Hub","text":"<ol> <li>In the hub scene, register each entrance point with the    <code>LevelManager</code> in its \"Points of Entry\" list.</li> <li>In the room scene, attach a <code>BoxCollider2D</code> and a    <code>GoToLevelEntryPoint</code> component to the exit door.</li> <li>Configure <code>GoToLevelEntryPoint</code> to:<ul> <li>Load the hub scene name, and</li> <li>Specify the correct entry index (matching the hub entrance from the   \"Points of Entry\" list).</li> </ul> </li> </ol> <p>This ensures that when the player returns, they appear at the correct hub entrance.</p>"},{"location":"implementation/SceneTransition/#important-note","title":"Important Note","text":"<p>Both the hub scene and all room scenes must be included in the Build Settings scene list. Unity cannot load scenes at runtime unless they\u2019re registered there.</p>"},{"location":"implementation/SceneTransition/#3-same-scene-teleports","title":"3. Same-Scene Teleports","text":"<p>Same-scene teleports allow moving between multiple points in the same scene. This should allowing building multiple rooms within the same scene, minimizing loading time.</p> <p>Corgi\u2019s <code>Teleporter</code> component can move characters between two positions within one scene, but by default:</p> <ul> <li>Adjacent rooms remain visible/active instead of being masked out.</li> <li>The camera is not confined to the new room\u2019s bounds.</li> </ul> <p>The built-in <code>Room</code> and <code>RoomManager</code> systems in Corgi appear to support this, but documentation is outdated and needs investigation.</p> <p>Next steps:</p> <ul> <li>Study how <code>RoomManager</code> constrains camera and visibility.</li> <li>Prototype same-scene room transitions with masking and camera limits.</li> <li>Evaluate performance and practicality compared to multi-scene transitions.</li> </ul> <p>Status: \ud83d\udfe1 Works, but not perfect yet.</p>"},{"location":"implementation/SceneTransition/#4-dungeon-traversal","title":"4. Dungeon Traversal","text":"<p>Before we can discuss how dungeon traversal works, we need to understand how dungeon generation is structured at a high level.</p> <p>The Dungeon Generator takes a <code>LevelGraph</code> as input and uses it to build a level. A <code>LevelGraph</code> defines:</p> <ul> <li>How room nodes are connected, and</li> <li>Which room prefabs can be used for each node.</li> </ul> <p>Each dungeon level in a run uses a different randomization seed (and possibly a different graph), but otherwise, the generation process is identical. Instead of maintaining dozens of nearly identical Unity scenes, we reuse a single base scene that contains the generator, and we pass in generation parameters at runtime.</p>"},{"location":"implementation/SceneTransition/#generation-parameters","title":"Generation Parameters","text":"<ul> <li>Base Seed: A single seed that determines the overall randomization for the   run.</li> <li>Level Number: An integer that identifies the current level within the run.</li> <li>Level Graphs: A list of predefined <code>LevelGraph</code> assets, one per dungeon   level (stored in the generator).</li> </ul> <p>Each level\u2019s generation seed is derived from the base seed:</p> <pre><code>level_seed = base_seed + level_number\n</code></pre> <p>The generator selects the corresponding <code>LevelGraph</code> from the list using the level number as an index.</p>"},{"location":"implementation/SceneTransition/#level-transition-flow","title":"Level Transition Flow","text":""},{"location":"implementation/SceneTransition/#1-entering-the-dungeon","title":"1. Entering the Dungeon","text":"<p>When the player enters the dungeon from the hub:</p> <ul> <li>The game records the base seed for the run.</li> <li>The next level number (usually <code>0</code> for the first dungeon level) is stored   in a static variable.</li> <li>The dungeon base scene is loaded, and the generator uses the parameters above   to build the level.</li> </ul> <p>This logic is handled by an extended version of the <code>FinishLevel</code> component.</p>"},{"location":"implementation/SceneTransition/#2-advancing-to-the-next-level","title":"2. Advancing to the Next Level","text":"<p>When the player reaches the end of a dungeon level:</p> <ul> <li>An extended <code>FinishLevel</code> component increments the static level number   (<code>level_number += 1</code>).</li> <li>The same base scene is reloaded.</li> <li>The generator uses the new level number and base seed to build the next level.</li> </ul> <p>This allows seamless multi-level progression without maintaining separate Unity scenes for each floor.</p>"},{"location":"implementation/SceneTransition/#3-returning-to-the-hub","title":"3. Returning to the Hub","text":"<p>At the end of a \u201cmeta-level\u201d (i.e., after the final floor of a dungeon branch), the exit uses a <code>GoToLevelEntryPoint</code> component instead of <code>FinishLevel</code>.</p> <p>This component:</p> <ul> <li>Loads the hub scene, and</li> <li>Positions the player at the correct gate or return point.</li> </ul>"},{"location":"implementation/SceneTransition/#4-reverse-traversal-experimental","title":"4. Reverse Traversal (Experimental)","text":"<p>We\u2019ve also implemented reverse traversal, though it\u2019s uncertain whether this will remain in the final game design.</p> <ul> <li>Interacting with the entrance of a dungeon level sends the player back to   the previous level\u2019s exit.</li> <li>This is done via an extended <code>GoToLevelEntryPoint</code> component that:<ul> <li>Decrements the level number (<code>level_number--</code>), and</li> <li>Sets the target point index to <code>0</code> (the registered exit spawn point).</li> </ul> </li> <li>The exit in each level also registers itself with the <code>LevelManager</code> as the   first point of entry, ensuring proper positioning when returning.</li> </ul>"},{"location":"implementation/SceneTransition/#spawn-synchronization-and-timing","title":"Spawn Synchronization and Timing","text":"<p>Because the generator builds rooms dynamically, there\u2019s a risk that the player might spawn before the designated entry point (entrance or exit) is registered. To prevent this race condition:</p> <ul> <li>The Level Manager delays player spawning by two frames, giving the   generated level time to register its spawn points and other initialization data.</li> <li>This simple delay has proven sufficient to ensure consistent and correct spawn   positioning.</li> </ul>"}]}